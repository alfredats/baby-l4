# Annotations in rules:

# * rule R1 subjectTo R2:

# - Applicability:
#   postcond(R1) && postcond(R2) are incompatible
#   (directly or under certain consistency requirements,
#   e.g. that maxSpeed is functional)

# - Effect:
#   add not(precond(R2)) to precond(R1)

# - R2 has priority over R1: R2 < R1

# - Synonymes:
#   rule R1 except as provided in R2
  

# * rule R1 despite R2:

# - Applicability:
#   postcond(R1) && postcond(R2) are incompatible

# - Effect:
#   add not(precond(R1)) to precond(R2)
#   the same has having:
#   rule R2 subjectTo R1

# - R1 has priority over R2: R1 < R2

# - Synonymes:
#   rule R1 notwithstanding R2

# - Remark:
#   for drafting purposes and modularity, "despite" seems preferable to "subjectTo"
#   because the overriding / more specialized rule references the overridden / more general rule

# ---> Conclusion: There is only one genuine prioritizing operator: subjectTo



### Fake example rules about speed limits of different kinds of vehicles
### on different days on different kinds of roads.

### Classes

class Vehicle
class Car extends Vehicle
class Truck extends Vehicle

class Day
class Workday extends Day
class Holiday extends Day

class Road
class Highway extends Road

### Predicates 

## uninteresting (the is... predicates should be generated)
# decl isVehicle : Vehicle -> Boolean
decl isCar : Vehicle -> Boolean
decl isTruck : Vehicle -> Boolean

# decl isDay : Day -> Boolean
decl isWorkday : Day -> Boolean
decl isHoliday : Day -> Boolean

# decl isRoad : Road -> Boolean
decl isHighway : Road -> Boolean

## interesting: the maximal speed of a vehicle on a day on a road is ...
# Could be modeled as a functional dependency, but this would
# make it impossible to verify that the relation is functional
decl maxSpeed : Vehicle -> Day -> Road -> Integer -> Boolean

# typical representatives of their class
decl instCar : Vehicle
decl instDay : Day
decl instRoad : Road
decl instSpeed1: Integer
decl instSpeed2: Integer

### Facts and rules

## Typing of the instances
# (typing of instDay and instRoad is a tautology)

fact <instCarType>
isCar instCar


## Class inclusion: follows from typing


## Class disjointness (possible to automate)

# top-level classes: follows from typing

# subclasses of Vehicle
fact <CarTrDistinct>
for c: Vehicle
not (isCar c && isTruck c)

# subclasses of Day
fact <WdHdDistinct>
for c: Day
not (isWorkday c && isHoliday c)


## Domain-specific rules

rule <maxSpCarWorkdayHighway>
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d && isHighway r
then maxSpeed v d r 130

# "Incorrect" version not excluding highways as roads
rule <maxSpCarWorkdayRoad>
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d
then maxSpeed v d r 90

###### subjectTo

# "Corrected" version with subjectTo clause
rule <maxSpCarWorkdayRoadRestrSubjectTo> 
    {restrict: {subjectTo: maxSpCarWorkdayHighway}}
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d
then maxSpeed v d r 90

rule <maxSpCarWorkdayRoad>
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d &&
 not( isCar v && isWorkday d && isHighway r)
then maxSpeed v d r 90



# The above translates to the two:

rule <maxSpCarWorkdayRoadRestrSubjectTo'Original> 
    {defined}
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d
then maxSpeed v d r 90

# the name should be maxSpCarWorkdayRoadRestrSubjectTo and not ...'Derived
rule <maxSpCarWorkdayRoadRestrSubjectTo'Derived> 
     {derived: {apply: {restrictWithNegPrecondOf, maxSpCarWorkdayRoadRestrSubjectTo'Original, maxSpCarWorkdayHighway}}}



# "Corrected" version making subjectTo explicit
rule <maxSpCarWorkdayRoadRestrSubjectToExpl> 
#     {subjectTo: maxSpCarWorkdayHighway}
#    && not (isCar v && isWorkday d && isHighway r && s = 130)
for v: Vehicle, d: Day, r: Road
if isCar v && isWorkday d && not (isHighway r)
then maxSpeed v d r 90



###### Despite

# in the following example, neither of the rules is more specific than the other

rule <maxSpHighway>
     {restrict: {despite: maxSpTruck}}
for v: Vehicle, d: Day, r: Road
if isHighway r
then maxSpeed v d r 130

rule <maxSpTruck>
for v: Vehicle, d: Day, r: Road
if isTruck v  && 
    isWorkday d &&
then maxSpeed v d r 100




# rewrites in a first step to:

rule <maxSpHighway>
     {restrict: {despite: maxSpTruckOnWorkday}}
for v: Vehicle, d: Day, r: Road
if isHighway r && isWorkday d
then maxSpeed v d r 130

rule <maxSpTruck>
     {restrict: {subjectTo: maxSpHighway}}
for v: Vehicle, d: Day, r: Road
if isTruck v
then maxSpeed v d r 100










# then, <maxSpTruck> rewrites in a second step to:

rule <maxSpTruck'Original>
     {defined}
for v: Vehicle, d: Day, r: Road
if isTruck v
then maxSpeed v d r 100

rule <maxSpTruck>
     {derived: {apply: {restrictWithNegPrecondOf, maxSpTruck'Original, maxSpHighway}}}

# then, <maxSpTruck> rewrites in a third step to:

rule <maxSpTruck>
     {defined}
for v: Vehicle, d: Day, r: Road
if isTruck v && not isHighway r
then maxSpeed v d r 100
     

###### Inversion

# Inversion of rules maxSpCarWorkdayHighway and maxSpCarWorkdayRoad
rule <maxSpInversion>
for v: Vehicle, d: Day, r: Road, s: Integer
if maxSpeed v d r s
then
 (isCar v && isWorkday d && isHighway r && s = 130) ||
 (isCar v && isWorkday d && s =  90)

# Inversion of rules maxSpCarWorkdayHighway and maxSpCarWorkdayRoadRestrSubjectTo
rule <maxSpInversionSubjectTo>
for v: Vehicle, d: Day, r: Road, s: Integer
if maxSpeed v d r s
then
 (isCar v && isWorkday d && isHighway r && s = 130) ||
 (isCar v && isWorkday d && s =  90 && not (isHighway r))

rule <maxSpInversionSubjectToDerived>
     {derived: {apply: {inversion,
                          list: {apply: {normalize, maxSpCarWorkdayRoad},
			         apply: {normalize, maxSpCarWorkdayRoadRestrSubjectTo}}}}}


# Non-functionality of maxSpeed is consistent with the assumption set
# including the incorrect maxSpCarWorkdayRoad
# --> satisfiable
assert <maxSpeedNotFunctionalWOsubjectToClause>
       {nSMT:
           {consistent, 
            rules: {only: {instCarType,
                          WdHdDistinct, CarTrDistinct,
                          maxSpCarWorkdayHighway,
                          maxSpCarWorkdayRoad,
                          maxSpInversion
                          }
                   },
            config: {solver: z3, logic: LIA, loglevel: 0}
           },
        nsCASP: {}
       }
maxSpeed instCar instDay instRoad instSpeed1 &&
maxSpeed instCar instDay instRoad instSpeed2 &&
instSpeed1 < instSpeed2

# Non-functionality of maxSpeed is consistent with the assumption set
# including the correct maxSpCarWorkdayRoadRestrSubjectTo and maxSpInversionSubjectTo
# --> unsatisfiable
assert {nSMT:
           {consistent, 
            rules: {only: {instCarType,
                          WdHdDistinct, CarTrDistinct,
                          maxSpCarWorkdayHighway,
                          maxSpCarWorkdayRoadRestrSubjectTo,
                          maxSpInversionSubjectTo
                          }
                   }
           }
       }
maxSpeed instCar instDay instRoad instSpeed1 &&
maxSpeed instCar instDay instRoad instSpeed2 &&
instSpeed1 < instSpeed2


# Functionality of maxSpeed follows from incorrect assumption set
# excluding the correct maxSpCarWorkdayRoadRestrSubjectTo and maxSpInversionSubjectTo 
# --> not valid, countermodel generated
assert {nSMT:
           {valid, 
            rules: {del : {maxSpCarWorkdayRoadRestrSubjectTo, maxSpInversionSubjectTo}}
           }
       }
maxSpeed instCar instDay instRoad instSpeed1 &&
maxSpeed instCar instDay instRoad instSpeed2
--> instSpeed1 = instSpeed2

# Functionality of maxSpeed follows from correct assumption set
# excluding the incorrect maxSpCarWorkdayRoad, maxSpInversion
# --> valid
assert {nSMT:
           {valid, 
            rules: {del : {maxSpCarWorkdayRoad, maxSpInversion}}
           }
       }
maxSpeed instCar instDay instRoad instSpeed1 &&
maxSpeed instCar instDay instRoad instSpeed2
--> instSpeed1 = instSpeed2


# TODO: construct the above assertion (but universally quantified):
# maxSpeed is functional in its 4th argument
assert <maxSpeedFunctionalDerived>
       {derived: {functional: {maxSpeed: 4},
                  rules: {del : {maxSpCarWorkdayRoad, maxSpInversion}}},
        valid}


# TODO: also admit assertions as facts
assert <maxSpeedNoConflict>
       {derived: {apply: {conjunction, rules: {only: foo1, foo2, maxSpeedFunctionalDerived}}},
        consistent}
       
assert {nSMT:
           {valid, 
            rules: {del : {maxSpCarWorkdayRoad, maxSpInversion}},
            config: {loglevel: 1}
           }
       }
isCar instCar -->
isWorkday instDay -->
isHighway instRoad -->
maxSpeed instCar instDay instRoad 90

assert {SMT: {valid,
              rules:
              {only: {CarTrDistinct, WdHdDistinct, maxSpCarWorkdayHighway, maxSpCarWorkdayRoadRestrSubjectTo, maxSpInversionSubjectTo}},
              config: {loglevel: 1}}}
forall v: Vehicle. forall d: Day. forall r: Road. forall s: Integer.
(isCar v && isWorkday d && not (isCar v && isWorkday d && isHighway r))
=
(isCar v && isWorkday d )



assert {nSMT: {valid, rules: {only:}, config: {loglevel: 1}}}
forall v: Vehicle. forall d: Day. forall r: Road. forall s: Integer.
(isCar v && isWorkday d ) -->
(isCar v && isWorkday d && not (isCar v && isWorkday d && isHighway r))

